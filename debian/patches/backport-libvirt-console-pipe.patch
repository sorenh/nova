Description: Move console.log to a ringbuffer
Author: Robie Basak <robie.basak@canonical.com>
Status: https://review.openstack.org/#change,706
diff -Naurp nova-2011.3.orig//nova/utils.py nova-2011.3//nova/utils.py
--- nova-2011.3.orig//nova/utils.py	2011-09-22 08:02:23.000000000 -0400
+++ nova-2011.3//nova/utils.py	2011-09-29 13:57:43.562487261 -0400
@@ -26,10 +26,12 @@ import json
 import lockfile
 import netaddr
 import os
+import os.path
 import random
 import re
 import shlex
 import socket
+import stat
 import struct
 import sys
 import time
@@ -49,6 +51,7 @@ from nova import log as logging
 from nova import version
 
 
+BITS_PER_BYTE = 8
 LOG = logging.getLogger("nova.utils")
 ISO_TIME_FORMAT = "%Y-%m-%dT%H:%M:%SZ"
 PERFECT_TIME_FORMAT = "%Y-%m-%dT%H:%M:%S.%f"
@@ -910,3 +913,130 @@ def convert_to_list_dict(lst, label):
     if not isinstance(lst, list):
         lst = [lst]
     return [{label: x} for x in lst]
+
+
+class RingBuffer(object):
+    """Generic userspace on-disk ringbuffer implementation."""
+    _header_max_int = (2 ** (struct.calcsize('I') * BITS_PER_BYTE)) - 1
+    _header_format = 'II'
+    _header_size = struct.calcsize(_header_format)
+
+    def __init__(self, backing_file, max_size=65536):
+        max_size += 1 # we need one extra byte as the buffer is kept with
+                      # one byte free to avoid the head==tail full/empty
+                      # problem
+        if not 0 < max_size <= RingBuffer._header_max_int:
+            raise ValueError('RingBuffer size out of range')
+        had_already_existed = os.path.exists(backing_file)
+        self.f = self._open(backing_file)
+        if had_already_existed:
+            file_size = os.fstat(self.f.fileno()).st_size
+            if file_size:
+                current_size = file_size - self._header_size
+                if not 0 < current_size <= RingBuffer._header_max_int:
+                    self.f.close()
+                    raise ValueError('Disk RingBuffer size out of range')
+                self.max_size = current_size
+
+                # If the file doesn't contain a header, assume it is corrupt
+                # and recreate
+                if file_size < self._header_size:
+                    self._write_header(0, 0) # initialise to empty
+
+                # If head or tail point beyond the file then bomb out
+                head, tail = self._read_header()
+                if head >= current_size or tail >= current_size:
+                    self.f.close()
+                    raise ValueError('RingBuffer %s is corrupt' % backing_file)
+            else:
+                # File is zero bytes: treat as new file
+                self.max_size = max_size
+                self._initialise_empty_file()
+        else:
+            self.max_size = max_size
+            self._initialise_empty_file()
+
+    def _initialise_empty_file(self):
+        os.ftruncate(self.f.fileno(), self.max_size + self._header_size)
+        self._write_header(0, 0) # head == tail means no data
+
+    @staticmethod
+    def _open(filename):
+        """Open a file without truncating it for both reading and writing in
+        binary mode."""
+        # Built-in open() cannot open in read/write mode without truncating.
+        fd = os.open(filename, os.O_RDWR | os.O_CREAT, 0666)
+        return os.fdopen(fd, 'w+')
+
+    def _read_header(self):
+        self.f.seek(0)
+        return struct.unpack(self._header_format,
+                             self.f.read(self._header_size))
+
+    def _write_header(self, head, tail):
+        self.f.seek(0)
+        self.f.write(struct.pack(self._header_format, head, tail))
+
+    def _seek(self, pos):
+        """Seek to pos in data (ignoring header)."""
+        self.f.seek(self._header_size + pos)
+
+    def _read_slice(self, start, end):
+        if start == end:
+            return ''
+
+        self._seek(start)
+        return self.f.read(end - start)
+
+    def _write_slice(self, pos, data):
+        self._seek(pos)
+        self.f.write(data)
+
+    def peek(self):
+        """Read the entire ringbuffer without consuming it."""
+        head, tail = self._read_header()
+        if head < tail:
+            # Wraps around
+            before_wrap = self._read_slice(tail, self.max_size)
+            after_wrap = self._read_slice(0, head)
+            return before_wrap + after_wrap
+        else:
+            # Just from here to head
+            return self._read_slice(tail, head)
+
+    def write(self, data):
+        """Write some amount of data to the ringbuffer, discarding the oldest
+        data as max_size is exceeded."""
+        head, tail = self._read_header()
+        while data:
+            # Amount of data to be written on this pass
+            len_to_write = min(len(data), self.max_size - head)
+
+            # Where head will be after this write
+            new_head = head + len_to_write
+
+            # In the next comparison, new_head may be self.max_size which is
+            # logically the same point as tail == 0 and must still be within
+            # the range tested.
+            unwrapped_tail = tail if tail else self.max_size
+
+            if head < unwrapped_tail <= new_head:
+                # Write will go past tail so tail needs to be pushed back
+                tail = new_head + 1 # one past head to indicate full
+                tail %= self.max_size
+                self._write_header(head, tail)
+
+            # Write the data
+            self._write_slice(head, data[:len_to_write])
+            data = data[len_to_write:] # data now left
+
+            # Push head back
+            head = new_head
+            head %= self.max_size
+            self._write_header(head, tail)
+
+    def flush(self):
+        self.f.flush()
+
+    def close(self):
+        self.f.close()
diff -Naurp nova-2011.3.orig//nova/virt/libvirt/connection.py nova-2011.3//nova/virt/libvirt/connection.py
--- nova-2011.3.orig//nova/virt/libvirt/connection.py	2011-09-22 08:02:23.000000000 -0400
+++ nova-2011.3//nova/virt/libvirt/connection.py	2011-09-29 13:40:41.392475523 -0400
@@ -37,6 +37,7 @@ Supports KVM, LXC, QEMU, UML, and XEN.
 
 """
 
+import errno
 import hashlib
 import functools
 import multiprocessing
@@ -44,7 +45,9 @@ import netaddr
 import os
 import random
 import re
+import select
 import shutil
+import stat
 import sys
 import tempfile
 import time
@@ -52,6 +55,7 @@ import uuid
 from xml.dom import minidom
 from xml.etree import ElementTree
 
+import eventlet
 from eventlet import greenthread
 from eventlet import tpool
 
@@ -141,6 +145,8 @@ flags.DEFINE_string('default_local_forma
 flags.DEFINE_bool('libvirt_use_virtio_for_bridges',
                   False,
                   'Use virtio for bridge interfaces')
+flags.DEFINE_integer('libvirt_console_log_size', 2**16,
+                     'libvirt console log ringbuffer size')
 
 
 def get_connection(read_only):
@@ -170,6 +176,55 @@ def _get_eph_disk(ephemeral):
     return 'disk.eph' + str(ephemeral['num'])
 
 
+class ConsoleLogger(object):
+
+    def __init__(self, fifo_path, ringbuffer_path):
+        self.fifo_path = fifo_path
+        self.fd = None
+        self.data_queue = eventlet.queue.LightQueue(0)
+        self.ringbuffer = utils.RingBuffer(ringbuffer_path,
+                                           FLAGS.libvirt_console_log_size)
+        self.reader_thread = eventlet.spawn(self._reader_thread_func)
+        self.writer_thread = eventlet.spawn(self._writer_thread_func)
+
+    def _reopen(self):
+        if self.fd is not None:
+            os.close(self.fd)
+        self.fd = os.open(self.fifo_path, os.O_RDONLY | os.O_NONBLOCK)
+
+    def _reader_thread_func(self):
+        self._reopen()
+        while True:
+            select.select([self.fd], [], [])
+            data = os.read(self.fd, 1024)
+            if data:
+                self.data_queue.put(data)
+            else:
+                self._reopen()
+
+    def _writer_thread_func(self):
+        try:
+            data = self.data_queue.get()
+            while data:
+                self.ringbuffer.write(data)
+                data = self.data_queue.get()
+        finally:
+            self.ringbuffer.close()
+
+    def close(self):
+        self.reader_thread.kill()
+        self.data_queue.put(None)
+        try:
+            self.writer_thread.wait()
+        except eventlet.greenlet.GreenletExit:
+            pass
+        if self.fd is not None:
+            os.close(self.fd)
+
+    def peek(self):
+        return self.ringbuffer.peek()
+
+
 class LibvirtConnection(driver.ComputeDriver):
 
     def __init__(self, read_only):
@@ -185,6 +240,8 @@ class LibvirtConnection(driver.ComputeDr
         self.firewall_driver = fw_class(get_connection=self._get_connection)
         self.vif_driver = utils.import_object(FLAGS.libvirt_vif_driver)
 
+        self.console_loggers = dict()
+
     def init_host(self, host):
         # NOTE(nsokolov): moved instance restarting to ComputeManager
         pass
@@ -229,6 +286,15 @@ class LibvirtConnection(driver.ComputeDr
         else:
             return libvirt.openAuth(uri, auth, 0)
 
+    def _start_console_logger(self, name, fifo_path, ringbuffer_path):
+        self._stop_console_logger(name)
+        self.console_loggers[name] = ConsoleLogger(fifo_path, ringbuffer_path)
+
+    def _stop_console_logger(self, name):
+        if name in self.console_loggers:
+            self.console_loggers[name].close()
+            del self.console_loggers[name]
+
     def list_instances(self):
         return [self._conn.lookupByID(x).name()
                 for x in self._conn.listDomainsID()]
@@ -333,6 +399,7 @@ class LibvirtConnection(driver.ComputeDr
     def _cleanup(self, instance):
         target = os.path.join(FLAGS.instances_path, instance['name'])
         instance_name = instance['name']
+        self._stop_console_logger(instance_name)
         LOG.info(_('instance %(instance_name)s: deleting instance files'
                 ' %(target)s') % locals())
         if FLAGS.libvirt_type == 'lxc':
@@ -652,24 +719,22 @@ class LibvirtConnection(driver.ComputeDr
 
     @exception.wrap_exception()
     def get_console_output(self, instance):
-        console_log = os.path.join(FLAGS.instances_path, instance['name'],
-                                   'console.log')
+        console_fifo = os.path.join(FLAGS.instances_path, instance['name'],
+                                   'console.fifo.out')
 
-        utils.execute('chown', os.getuid(), console_log, run_as_root=True)
+        utils.execute('chown', os.getuid(), console_fifo, run_as_root=True)
 
         if FLAGS.libvirt_type == 'xen':
             # Xen is special
             virsh_output = utils.execute('virsh', 'ttyconsole',
                                          instance['name'])
             data = self._flush_xen_console(virsh_output)
-            fpath = self._append_to_file(data, console_log)
+            self._append_to_file(data, console_fifo)
         elif FLAGS.libvirt_type == 'lxc':
             # LXC is also special
             LOG.info(_("Unable to read LXC console"))
-        else:
-            fpath = console_log
 
-        return self._dump_file(fpath)
+        return self.console_loggers[instance['name']].peek()
 
     @exception.wrap_exception()
     def get_ajax_console(self, instance):
@@ -816,11 +881,23 @@ class LibvirtConnection(driver.ComputeDr
             container_dir = '%s/rootfs' % basepath(suffix='')
             utils.execute('mkdir', '-p', container_dir)
 
-        # NOTE(vish): No need add the suffix to console.log
-        console_log = basepath('console.log', '')
-        if os.path.exists(console_log):
-            utils.execute('chown', os.getuid(), console_log, run_as_root=True)
-        os.close(os.open(console_log, os.O_CREAT | os.O_WRONLY, 0660))
+        # NOTE(vish): No need add the suffix
+        console_fifo = basepath('console.fifo', '')
+        console_ring = basepath('console.ring', '')
+
+        for suffix in [ '.in', '.out' ]:
+            console_fifo_suffix = console_fifo + suffix
+            try:
+                console_fifo_stat = os.stat(console_fifo_suffix)
+            except OSError, e:
+                if e.errno == errno.ENOENT:
+                    os.mkfifo(console_fifo_suffix, 0660)
+                else:
+                    raise
+            else:
+                utils.execute('chown', os.getuid(), console_fifo_suffix,
+                              run_as_root=True)
+        self._start_console_logger(inst['name'], console_fifo + '.out', console_ring)
 
         if not disk_images:
             disk_images = {'image_id': inst['image_ref'],
diff -Naurp nova-2011.3.orig//nova/virt/libvirt.xml.template nova-2011.3//nova/virt/libvirt.xml.template
--- nova-2011.3.orig//nova/virt/libvirt.xml.template	2011-09-22 08:02:23.000000000 -0400
+++ nova-2011.3//nova/virt/libvirt.xml.template	2011-09-29 13:40:41.392475523 -0400
@@ -153,8 +153,8 @@
 
 #end for
         <!-- The order is significant here.  File must be defined first -->
-        <serial type="file">
-            <source path='${basepath}/console.log'/>
+        <serial type="pipe">
+            <source path='${basepath}/console.fifo'/>
             <target port='1'/>
         </serial>
 
